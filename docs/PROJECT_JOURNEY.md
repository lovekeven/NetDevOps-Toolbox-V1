# NetDevOps 工具箱项目演进日志

> 记录每一次。
## 2026年1月20日：实现系统指标监控和重要检查关键服务的健康状态
- **优化目标**：修复健康检查逻辑，修改nornir_tasks.py，让健康检查真正判断设备状态，创建基础监控模块，将指标记录到数据库，web_dashboard.py中添加监控端点
- **技术**：
  - 1.psutil 模块
  - 2.数据库插入表格的SQL语句
- **具体改动**：
  - 1.创建 monitoring.py，检查web仪表盘，数据库连接，Nornir框架是否正常和收集系统指标
  - 2.修改nornir_tasks.py，判断接口状态，CPU使用率，和内存使用率
  - 3.修改web仪表盘，增加两个新的API接口
  - 4.修改database.py,向数据库里面插入表格，来存储系统指标信息
- **学到的知识**：
  - 1.@staticmethod是 Python 的「静态方法装饰器」，作用是把类中的方法变成「不需要实例化就能调用的工具方法」—— 这是这个类设计的关键
  - 2.textplain 格式：这个 text/plain 格式，Prometheus 是「专属适配」（只认这个），前端是「通用兼容」（也能认）—— 不是只有 Prometheus 认识，只是 Prometheus 只认这一个。
  - 3.psutil.virtual_memory() 返回的是「内存的全量数据对象」，不止有使用率
  - 4.psutil就是 Python 的 “系统体检医生”，不用自己写复杂命令，直接拿系统状态；
- **提交哈希**：`267751d `（代码回溯：git checkout `267751d` ,git checkout --detach `267751d`，git checkout main（取消回溯））

## 2026年1月19日：实现备份历史记录与数据库连接，调用AI大模型分析结果，使用Nornir框架进行并发处理
- **优化目标**：实现备份历史记录与数据库连接，调用AI大模型分析结果，使用Nornir框架进行并发处理
- **技术**：
  - 1.Nornir框架
  - 2.数据库插入表格的SQL语句
- **具体改动**：
  - 1.添加数据库的脚本。
  - 2.添加调用 API 大模型的脚本
  - 3.添加Nornir框架，设备清单、主配置文件进行并发检查。
- **学到的知识**：
  - 1.Http协议和API调用
  - 2.环境变量的本质：是操作系统提供的「全局配置传递机制」，用于在不写入文件的前提下，给程序传递配置信息（尤其是敏感信息，比如 API Key、数据库密码）
  - 3.变量 response 是一个 requests.models.Response 类的实例对象，它是 requests 模块专门用于封装 HTTP 响应结果的对象，核心价值是「隐藏原始报文的解析复杂度，提供便捷方法来获取响应信息」。
  - 4.Result是 Nornir 框架定义的一个类（Class），Result类型的变量本质就是这个类的实例（对象），它自带框架封装好的内置属性（如failed、result、host等）
- **提交哈希**：`d3c061b    `（代码回溯：git checkout `d3c061b   ` ,git checkout --detach `d3c061b   `，git checkout main（取消回溯））

## 2026年1月14日：实现完整Flask Web仪表盘
- **优化目标**：通过Web界面直接触发设备配置备份，和健康检查
- **技术**：
  - 1.Flask 核心框架：路由定义（@app.route()装饰器）
  - 2.API模块中定义了类（可调用）
- **具体改动**：
  - 1.在API模块里定义查寻云端服务器的函数，和查询设备的函数
  - 2.异常处理：捕获设备连接失败、请求异常等，返回友好提示给前端。
  - 3.fetch() API：发送异步请求到 Flask 后端（触发备份 / 健康检查）
- **学到的知识**：
  - 1.JS 对象（普通对象）的核心格式就是「键值对」，和 Python 字典几乎是 “双胞胎”，结构上高度一致，只是语法上有细微差异。
  - 2.点击按钮是「异步后台请求」（通过fetch实现），特点是：地址栏 URL 始终保持不变，只是在 “后台悄悄” 和后端通信，用户感知不到除了 “按钮置灰、状态更新” 之外的变化
  - 3.后端返回的信息在技术层面给了前端，而用户看到的是前端控制的。前端想让你看到什么，你就看到什么
  - 4.每个设备的健康检查按钮，都被绑定了自己的设备名（SW1/SW2），相当于给按钮贴了一个 “设备名标签”
- **提交哈希**：`de3a9a9   `（代码回溯：git checkout `de3a9a9  ` ,git checkout --detach `de3a9a9  `，git checkout main（取消回溯））

## 2026年1月11日：装饰器（重试机制）和新增API模块
- **优化目标**：为函数`backup.py`和`api_checker.py`增加容错率
- **技术**：
  - 1.从`typling`模块中引入了类型注解：`Dict, Any, Optional，Callable`等等
  - 2.API模块中定义了类（可调用）
- **具体改动**：
  - 1.在API模块里定义查寻云端服务器的函数，和查询设备的函数
  - 2.在`backup.py`模块里引入装饰器，增加容错率
- **学到的知识**：
  - 1.Python里，一切皆对象，装饰器和对应的函数对象息息相关
  - 2.`raise`的传递对象只有一个,当前执行 raise 语句的函数的「直接调用方」，简单说：“谁调用我，我就把异常传给谁”
  - 3.位置参数和关键字参数的区别
  - 4.`*args`,`**kwargs`:前者收集位置参数，解包可迭代对象。后者收集关键字参数，解包只能是字典
  - 5.`delay:.1f`:将delay这个浮点数格式化为保留1位小数的字符串
- **提交哈希**：`5f2d410  `（代码回溯：git checkout `5f2d410 ` ,git checkout --detach `5f2d410 `，git checkout main（取消回溯））

## 2026年1月3日：引入单元测试
- **优化目标**：为核心函数 `read_devices_yml` 增加质量保障,方便测试呗
- **技术**：
  - 1.使用了`pytest`单元测试工具
- **具体改动**：
  - 1.在`test_device_reader.py`和`health_check.py`开头添加`sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))`；
  - 2.将脚本所在目录插入`sys.path`首位，确保优先搜索项目内模块。
- **学到的知识**：
  - 1.`sys.path`的搜索顺序决定模块优先级,并且他是运行的时候，才会查询目录，默认是查询运行脚本时当前目录
  - 2.`pytest -v`会查询子文件夹，有递归。`pytest -v -no-recyrseondirs`禁用递归仅当前目录
- **提交哈希**：`3bb695d `（代码回溯：git checkout `3bb695d` ,git checkout --detach `3bb695d`，git checkout main（取消回溯））

## 2026年1月2日：重构日志系统，实现统一配置模块
- **优化目标**：增加日志器
- **技术**：
  - 1.使用Python标准库`logging`
- **具体改动**：
  - 1.创建`log_setup.py`，封装日志配置，替换`print`语句；
- **学到的知识**：
  - 1.在`log_setuo.py` 里定义的日志器函数，日志器的名字是自定义的，`.log`文件也是自定义的，自己想更改的话，需要在其他脚本自行设置
  - 2.在其他函数导入模块的话，则会执行顶层代码，可能会导致也用了默认的日志器，会多一个`.log`文件
  - 3.日志重复打印，原因是`logger.propagate`默认值为`True`，需手动设为`False`；
- **提交哈希**：`0c75e8b`（代码回溯：git checkout `0c75e8b`，git checkout --detach `0c75e8b`，git checkout main（取消回溯））
